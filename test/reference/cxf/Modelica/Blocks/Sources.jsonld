{
  "@context": {
    "S231P": "https://data.ashrae.org/S231P#"
  },
  "@id": "http://example.org#Modelica.Blocks.Sources",
  "@type": "S231P:Block",
  "S231P:documentation": [
    "info=<html>\n\n<p>\nThis block generates an Integer output signal by using a table.\nThe time points and y-values are stored in a matrix\n<strong>table[i,j]</strong>, where the first column table[:,1] contains the\nReal time points and the second column contains the Integer value of the\noutput y at this time point.\nThe table interpolation has the following properties:\n</p>\n\n<ul>\n<li>An assert is triggered, if no table values are provided, if the\n    time points are not strict monotonically increasing, or if\n    the second column of the table matrix does not contain Integer values.</li>\n<li>Values <strong>outside</strong> of the table range, are computed by\n    extrapolation according to the setting of parameter <strong>extrapolation</strong>:\n<blockquote><pre>\nextrapolation = 1: Hold the first or last value of the table,\n                   if outside of the table scope.\n              = 2: Extrapolate by using the derivative at the first/last table\n                   points if outside of the table scope.\n                   (This setting is not suitable and triggers an assert.)\n              = 3: Periodically repeat the table data (periodical function).\n              = 4: No extrapolation, i.e. extrapolation triggers an error\n</pre></blockquote></li>\n<li>If the table has only <strong>one row</strong>, no interpolation is performed and\n    the table values of this row are just returned.</li>\n<li>Via parameter <strong>shiftTime</strong> the curve defined by the table can be shifted\n    in time.\n    The time instants stored in the table are therefore <strong>relative</strong>\n    to <strong>shiftTime</strong>.</li>\n<li>If time &lt; startTime, no interpolation is performed and zero\n    is used as ordinate value for the output.</li>\n</ul>\n\n<p>\nExample:\n</p>\n<blockquote><pre>\ntable = [  0, 1;\n           1, 4;\n         1.5, 5;\n           2, 6];\n</pre></blockquote>\n<p>\nresults in the following output:\n</p>\n\n<blockquote><p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/IntegerTable.png\\\n     alt=\\IntegerTable.png\\>\n</p></blockquote>\n\n</html>",
    "info=<html>\n<p>\nBoolean signal source that mimics a radio button:\nVia a table, a radio button is pressed (i.e., the output on is set to true) and is reset when an element of the Boolean vector\nreset becomes true. If both appear at the same time instant, setting\nthe button according to the table has a higher priority as resetting\nthe button. Example:\n</p>\n\n<blockquote><pre>\nRadioButtonSource start(buttonTimeTable={1,3}, reset={stop.on});\nRadioButtonSource stop (buttonTimeTable={2,4}, reset={start.on});\n</pre></blockquote>\n\n<p>\nThe \\start\\ button is pressed at time=1 s and time=3 s,\nwhereas the \\stop\\ button is pressed at time=2 s and time=4 s.\nThis gives the following result:\n</p>\n\n<blockquote>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/RadioButtonSource.png\\\n     alt=\\RadioButtonSource.png\\>\n</blockquote>\n\n<p>\nThis example is also available in\n<a href=\\modelica://Modelica.Blocks.Examples.Interaction1\\>Modelica.Blocks.Examples.Interaction1</a>\n</p>\n\n</html>",
    "info=<html>\n<p>\nThe (time varying) Boolean output signal of this block can be defined in its\nparameter menu via variable <strong>y</strong>. The purpose is to support the\neasy definition of Boolean expressions in a block diagram. For example,\nin the y-menu the definition \\time &gt;= 1 and time &lt;= 2\\ can be given in order\nto define that the output signal is <strong>true</strong> in the time interval\n1 &le; time &le; 2 and otherwise it is <strong>false</strong>.\nNote, that \\time\\ is a built-in variable that is always\naccessible and represents the \\model time\\ and that\nvariable <strong>y</strong> is both a variable and a connector.\n</p>\n</html>",
    "info=<html>\n<p>\nThe (time varying) Integer output signal of this block can be defined in its\nparameter menu via variable <strong>y</strong>. The purpose is to support the\neasy definition of Integer expressions in a block diagram. For example,\nin the y-menu the definition \\if time &lt; 1 then 0 else 1\\ can be given in order\nto define that the output signal is one, if time &ge; 1 and otherwise\nit is zero. Note, that \\time\\ is a built-in variable that is always\naccessible and represents the \\model time\\ and that\nvariable <strong>y</strong> is both a variable and a connector.\n</p>\n</html>",
    "info=<html>\n<p>\nThe (time varying) Real output signal of this block can be defined in its\nparameter menu via variable <strong>y</strong>. The purpose is to support the\neasy definition of Real expressions in a block diagram. For example,\nin the y-menu the definition \\if time &lt; 1 then 0 else 1\\ can be given in order\nto define that the output signal is one, if time &ge; 1 and otherwise\nit is zero. Note, that \\time\\ is a built-in variable that is always\naccessible and represents the \\model time\\ and that\nvariable <strong>y</strong> is both a variable and a connector.\n</p>\n</html>",
    "info=<html>\n<p>\nThe Boolean output y is a constant signal:\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/BooleanConstant.png\\\n     alt=\\BooleanConstant.png\\>\n</p>\n</html>",
    "info=<html>\n<p>\nThe Boolean output y is a pulse signal:\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/Pulse.png\\\n     alt=\\Pulse.png\\>\n</p>\n</html>",
    "info=<html>\n<p>\nThe Boolean output y is a signal defined by parameter vector <strong>table</strong>.\nIn the vector time points are stored.\nThe table interpolation has the following properties:\n</p>\n\n<ul>\n<li>At every time point, the output y\n    changes its value to the negated value of the previous one.</li>\n<li>Values <strong>outside</strong> of the table range, are computed by\n    extrapolation according to the setting of parameter <strong>extrapolation</strong>:\n<blockquote><pre>\nextrapolation = 1: Hold the <strong>startValue</strong> or last value of the table,\n                   if outside of the table scope.\n              = 2: Extrapolate by using the derivative at the first/last table\n                   points if outside of the table scope.\n                   (This setting is not suitable and triggers an assert.)\n              = 3: Periodically repeat the table data (periodical function).\n              = 4: No extrapolation, i.e. extrapolation triggers an error\n</pre></blockquote></li>\n<li>Via parameter <strong>shiftTime</strong> the curve defined by the table can be shifted\n    in time.\n    The time instants stored in the table are therefore <strong>relative</strong>\n    to <strong>shiftTime</strong>.</li>\n<li>If time &lt; startTime, no interpolation is performed and <strong>false</strong>\n    is used as ordinate value for the output.</li>\n</ul>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/BooleanTable.png\\\n     alt=\\BooleanTable.png\\>\n</p>\n\n<p>\nThe precise semantics is:\n</p>\n\n<blockquote><pre>\n<strong>if</strong> size(table,1) == 0 <strong>then</strong>\n   y = startValue;\n<strong>else</strong>\n   //            time &lt; table[1]: y = startValue\n   // table[1] &le; time &lt; table[2]: y = not startValue\n   // table[2] &le; time &lt; table[3]: y = startValue\n   // table[3] &le; time &lt; table[4]: y = not startValue\n   // ...\n<strong>end if</strong>;\n</pre></blockquote>\n</html>",
    "info=<html>\n<p>\nThe Boolean output y is a step signal:\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/BooleanStep.png\\\n     alt=\\BooleanStep.png\\>\n</p>\n</html>",
    "info=<html>\n<p>\nThe Boolean output y is a trigger signal where the output y is only <strong>true</strong>\nat sample times (defined by parameter <strong>period</strong>) and is otherwise\n<strong>false</strong>.\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/SampleTrigger.png\\\n     alt=\\SampleTrigger.png\\>\n</p>\n</html>",
    "info=<html>\n<p>\nThe Integer output y is a constant signal:\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/IntegerConstant.png\\\n     alt=\\IntegerConstant.png\\>\n</p>\n</html>",
    "info=<html>\n<p>\nThe Integer output y is a step signal:\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/IntegerStep.png\\\n     alt=\\IntegerStep.png\\>\n</p>\n</html>",
    "info=<html>\n<p>\nThe Real output y is a clock signal:\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/ContinuousClock.png\\\n     alt=\\ContinuousClock.png\\>\n</p>\n</html>",
    "info=<html>\n<p>\nThe Real output y is a constant signal:\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/Constant.png\\\n     alt=\\Constant.png\\>\n</p>\n</html>",
    "info=<html>\n<p>\nThe Real output y is a cosine signal:\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/Cosine.png\\\n     alt=\\Cosine.png\\>\n</p>\n</html>",
    "info=<html>\n<p>\nThe Real output y is a pulse signal:\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/Pulse.png\\\n     alt=\\Pulse.png\\>\n</p>\n</html>",
    "info=<html>\n<p>\nThe Real output y is a ramp signal:\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/Ramp.png\\\n     alt=\\Ramp.png\\>\n</p>\n\n<p>\nIf parameter duration is set to 0.0, the limiting case of a Step signal is achieved.\n</p>\n</html>",
    "info=<html>\n<p>\nThe Real output y is a rising exponential followed\nby a falling exponential signal:\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/Exponentials.png\\\n     alt=\\Exponentials.png\\>\n</p>\n</html>",
    "info=<html>\n<p>\nThe Real output y is a saw tooth signal:\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/SawTooth.png\\\n     alt=\\SawTooth.png\\>\n</p>\n</html>",
    "info=<html>\n<p>\nThe Real output y is a sinc signal: <code> amplitude*(sin(2*&pi;*f*t))/((2*&pi;*f*t))</code>\n</p>\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/Sinc.png\\\n     alt=\\Sinc.png\\>\n</p>\n</html>",
    "info=<html>\n<p>\nThe Real output y is a sine signal with exponentially changing amplitude:\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/ExpSine.png\\\n     alt=\\ExpSine.png\\>\n</p>\n</html>",
    "info=<html>\n<p>\nThe Real output y is a sine signal:\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/Sine.png\\\n     alt=\\Sine.png\\>\n</p>\n</html>",
    "info=<html>\n<p>\nThe Real output y is a step signal:\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/Step.png\\\n     alt=\\Step.png\\>\n</p>\n\n</html>",
    "info=<html>\n<p>\nThe Real output y is a trapezoid signal:\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/Trapezoid.png\\\n     alt=\\Trapezoid\\>\n</p>\n</html>",
    "info=<html>\n<p>\nThe goal is to move as <strong>fast</strong> as possible along a distance\n<strong>deltaq</strong>\nunder given <strong>kinematical constraints</strong>. The distance can be a positional or\nangular range. In robotics such a movement is called <strong>PTP</strong> (Point-To-Point).\nThis source block generates the <strong>acceleration</strong> qdd of this signal\nas output:\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/KinematicPTP.png\\\n     alt=\\KinematicPTP.png\\>\n</p>\n\n<p>\nAfter integrating the output two times, the position q is\nobtained. The signal is constructed in such a way that it is not possible\nto move faster, given the <strong>maximally</strong> allowed <strong>velocity</strong> qd_max and\nthe <strong>maximally</strong> allowed <strong>acceleration</strong> qdd_max.\n</p>\n<p>\nIf several distances are given (vector deltaq has more than 1 element),\nan acceleration output vector is constructed such that all signals\nare in the same periods in the acceleration, constant velocity\nand deceleration phase. This means that only one of the signals\nis at its limits whereas the others are synchronized in such a way\nthat the end point is reached at the same time instant.\n</p>\n\n<p>\nThis element is useful to generate a reference signal for a controller\nwhich controls a drive train or in combination with model\nModelica.Mechanics.Rotational.<strong>Accelerate</strong> to drive\na flange according to a given acceleration.\n</p>\n\n</html>,revisions=<html>\n<p><strong>Release Notes:</strong></p>\n<ul>\n<li><em>June 27, 2001</em>\n       by Bernhard Bachmann.<br>\n       Bug fixed that element is also correct if startTime is not zero.</li>\n<li><em>Nov. 3, 1999</em>\n       by <a href=\\http://www.robotic.dlr.de/Martin.Otter/\\>Martin Otter</a>:<br>\n       Vectorized and moved from Rotational to Blocks.Sources.</li>\n<li><em>June 29, 1999</em>\n       by <a href=\\http://www.robotic.dlr.de/Martin.Otter/\\>Martin Otter</a>:<br>\n       realized.</li>\n</ul>\n</html>",
    "info=<html>\n<p>\nThe goal is to move as <strong>fast</strong> as possible from start position <strong>q_begin</strong>\nto end position <strong>q_end</strong>\nunder given <strong>kinematical constraints</strong>. The positions can be translational or\nrotational definitions (i.e., q_begin/q_end is given). In robotics such a movement is called <strong>PTP</strong> (Point-To-Point).\nThis source block generates the <strong>position</strong> q(t), the\n<strong>speed</strong> qd(t) = der(q), and the <strong>acceleration</strong> qdd = der(qd)\nas output. The signals are constructed in such a way that it is not possible\nto move faster, given the <strong>maximally</strong> allowed <strong>velocity</strong> qd_max and\nthe <strong>maximally</strong> allowed <strong>acceleration</strong> qdd_max:\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/KinematicPTP2.png\\\n     alt=\\KinematicPTP2.png\\>\n</p>\n\n<p>\nIf vectors q_begin/q_end have more than 1 element,\nthe output vectors are constructed such that all signals\nare in the same periods in the acceleration, constant velocity\nand deceleration phase. This means that only one of the signals\nis at its limits whereas the others are synchronized in such a way\nthat the end point is reached at the same time instant.\n</p>\n\n<p>\nThis element is useful to generate a reference signal for a controller\nwhich controls, e.g., a drive train, or to drive\na flange according to a given acceleration.\n</p>\n\n</html>,revisions=<html>\n<ul>\n<li><em>March 24, 2007</em>\n       by <a href=\\http://www.robotic.dlr.de/Martin.Otter/\\>Martin Otter</a>:<br>\n       Non-standard Modelica function \\constrain(..)\\ replaced by standard\n       Modelica implementation (via internal function position()).<br>\n       New output signal \\moving\\ added.</li>\n<li><em>June 27, 2001</em>\n       by Bernhard Bachmann.<br>\n       Bug fixed that element is also correct if startTime is not zero.</li>\n<li><em>Nov. 3, 1999</em>\n       by <a href=\\http://www.robotic.dlr.de/Martin.Otter/\\>Martin Otter</a>:<br>\n       Vectorized and moved from Rotational to Blocks.Sources.</li>\n<li><em>June 29, 1999</em>\n       by <a href=\\http://www.robotic.dlr.de/Martin.Otter/\\>Martin Otter</a>:<br>\n       realized.</li>\n</ul>\n</html>",
    "info=<html>\n<p>\nThis block generates an output signal by <strong>linear interpolation</strong> in\na table. The time points and function values are stored in a matrix\n<strong>table[i,j]</strong>, where the first column table[:,1] contains the\ntime points and the second column contains the data to be interpolated.\nThe table interpolation has the following properties:\n</p>\n<ul>\n<li>The interpolation interval is found by a linear search where the interval used in the\n    last call is used as start interval.</li>\n<li>The time points need to be <strong>monotonically increasing</strong>.</li>\n<li><strong>Discontinuities</strong> are allowed, by providing the same\n    time point twice in the table.</li>\n<li>Values <strong>outside</strong> of the table range, are computed by\n    <strong>extrapolation</strong> through the last or first two points of the\n    table.</li>\n<li>If the table has only <strong>one row</strong>, no interpolation is performed and\n    the function value is just returned independently of the actual time instant.</li>\n<li>Via parameters <strong>shiftTime</strong> and <strong>offset</strong> the curve defined\n    by the table can be shifted both in time and in the ordinate value.\n    The time instants stored in the table are therefore <strong>relative</strong>\n    to <strong>shiftTime</strong>.</li>\n<li>If time &lt; startTime, no interpolation is performed and the offset\n    is used as ordinate value for the output.</li>\n<li>If the table has more than one row, the first point in time <strong>always</strong> has to be set to <strong>0</strong>, e.g.,\n    <strong>table=[1,1;2,2]</strong> is <strong>illegal</strong>. If you want to\n    shift the time table in time use the <strong>shiftTime</strong> parameter instead.</li>\n<li>The table is implemented in a numerically sound way by\n    generating <strong>time events</strong> at interval boundaries.\n    This generates continuously differentiable values for the integrator.</li>\n<li>Via parameter <strong>timeScale</strong> the first column of the table array can\n    be scaled, e.g., if the table array is given in hours (instead of seconds)\n    <strong>timeScale</strong> shall be set to 3600.</li>\n</ul>\n<p>\nExample:\n</p>\n<blockquote><pre>\n   table = [0, 0;\n            1, 0;\n            1, 1;\n            2, 4;\n            3, 9;\n            4, 16];\nIf, e.g., time = 1.0, the output y =  0.0 (before event), 1.0 (after event)\n    e.g., time = 1.5, the output y =  2.5,\n    e.g., time = 2.0, the output y =  4.0,\n    e.g., time = 5.0, the output y = 23.0 (i.e., extrapolation).\n</pre></blockquote>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/TimeTable.png\\\n     alt=\\TimeTable.png\\>\n</p>\n\n</html>,revisions=<html>\n<h4>Release Notes</h4>\n<ul>\n<li><em>Oct. 21, 2002</em>\n       by Christian Schweiger:<br>\n       Corrected interface from\n<blockquote><pre>\nparameter Real table[:, :]=[0, 0; 1, 1; 2, 4];\n</pre></blockquote>\n       to\n<blockquote><pre>\nparameter Real table[:, <strong>2</strong>]=[0, 0; 1, 1; 2, 4];\n</pre></blockquote>\n       </li>\n<li><em>Nov. 7, 1999</em>\n       by <a href=\\http://www.robotic.dlr.de/Martin.Otter/\\>Martin Otter</a>:<br>\n       Realized.</li>\n</ul>\n</html>",
    "info=<html>\n<p>\nThis block generates an output signal y[:] by <strong>constant</strong>,\n<strong>linear</strong> or <strong>cubic Hermite spline interpolation</strong>\nin a table. The time points and function values are stored in a matrix\n<strong>table[i,j]</strong>, where the first column table[:,1] contains the\ntime points and the other columns contain the data to be interpolated.\n</p>\n\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/CombiTimeTable.png\\\n     alt=\\CombiTimeTable.png\\>\n</p>\n\n<p>\nVia parameter <strong>columns</strong> it can be defined which columns of the\ntable are interpolated. If, e.g., columns={2,4}, it is assumed that\n2 output signals are present and that the first output is computed\nby interpolation of column 2 and the second output is computed\nby interpolation of column 4 of the table matrix.\nThe table interpolation has the following properties:\n</p>\n<ul>\n<li>The interpolation interval is found by a binary search where the interval used in the\n    last call is used as start interval.</li>\n<li>The time points need to be <strong>strictly increasing</strong> for cubic Hermite\n    spline interpolation, otherwise <strong>monotonically increasing</strong>.</li>\n<li><strong>Discontinuities</strong> are allowed for (constant or) linear interpolation,\n    by providing the same time point twice in the table.</li>\n<li>Via parameter <strong>smoothness</strong> it is defined how the data is interpolated:\n<blockquote><pre>\nsmoothness = 1: Linear interpolation\n           = 2: Akima interpolation: Smooth interpolation by cubic Hermite\n                splines such that der(y) is continuous, also if extrapolated.\n           = 3: Constant segments\n           = 4: Fritsch-Butland interpolation: Smooth interpolation by cubic\n                Hermite splines such that y preserves the monotonicity and\n                der(y) is continuous, also if extrapolated.\n           = 5: Steffen interpolation: Smooth interpolation by cubic Hermite\n                splines such that y preserves the monotonicity and der(y)\n                is continuous, also if extrapolated.\n           = 6: Modified Akima interpolation: Smooth interpolation by cubic\n                Hermite splines such that der(y) is continuous, also if\n                extrapolated. Additionally, overshoots and edge cases of the\n                original Akima interpolation method are avoided.\n</pre></blockquote></li>\n<li>First and second <strong>derivatives</strong> are provided, with exception of the following two smoothness options.\n<ol>\n<li>No derivatives are provided for interpolation by constant segments.</li>\n<li>No second derivative is provided for linear interpolation.<br>There is a design inconsistency, that it is possible\nto model a signal consisting of constant segments using linear interpolation and duplicated sample points.\nIn contrast to interpolation by constant segments, the first derivative is provided as zero.</li>\n</ol></li>\n<li>Values <strong>outside</strong> of the table range, are computed by\n    extrapolation according to the setting of parameter <strong>extrapolation</strong>:\n<blockquote><pre>\nextrapolation = 1: Hold the first or last value of the table,\n                   if outside of the table scope.\n              = 2: Extrapolate by using the derivative at the first/last table\n                   points if outside of the table scope.\n                   (If smoothness is LinearSegments or ConstantSegments\n                   this means to extrapolate linearly through the first/last\n                   two table points.).\n              = 3: Periodically repeat the table data (periodical function).\n              = 4: No extrapolation, i.e. extrapolation triggers an error\n</pre></blockquote></li>\n<li>If the table has only <strong>one row</strong>, no interpolation is performed and\n    the table values of this row are just returned.</li>\n<li>Via parameters <strong>shiftTime</strong> and <strong>offset</strong> the curve defined\n    by the table can be shifted both in time and in the ordinate value.\n    The time instants stored in the table are therefore <strong>relative</strong>\n    to <strong>shiftTime</strong>.</li>\n<li>If time &lt; startTime, no interpolation is performed and the offset\n    is used as ordinate value for all outputs.</li>\n<li>The table is implemented in a numerically sound way by\n    generating <strong>time events</strong> at interval boundaries, in case of\n    interpolation by linear segments.\n    This generates continuously differentiable values for the integrator.\n    Via parameter <strong>timeEvents</strong> it is defined how the time events are generated:\n<blockquote><pre>\ntimeEvents = 1: Always generate time events at interval boundaries\n           = 2: Generate time events at discontinuities (defined by duplicated sample points)\n           = 3: No time events at interval boundaries\n</pre></blockquote>\n    For interpolation by constant segments time events are always generated at interval boundaries.\n    For smooth interpolation by cubic Hermite splines no time events are generated at interval boundaries.</li>\n<li>Via parameter <strong>timeScale</strong> the first column of the table array can\n    be scaled, e.g., if the table array is given in hours (instead of seconds)\n    <strong>timeScale</strong> shall be set to 3600.</li>\n<li>For special applications it is sometimes needed to know the minimum\n    and maximum time instant defined in the table as a parameter. For this\n    reason parameters <strong>t_min</strong>/<strong>t_minScaled</strong> and\n    <strong>t_max</strong>/<strong>t_maxScaled</strong> are provided and can be\n    accessed from the outside of the table object. Whereas <strong>t_min</strong> and\n    <strong>t_max</strong> define the scaled abscissa values (using parameter\n    <strong>timeScale</strong>) in SI.Time, <strong>t_minScaled</strong> and\n    <strong>t_maxScaled</strong> define the unitless original abscissa values of\n    the table.</li>\n</ul>\n<p>\nExample:\n</p>\n<blockquote><pre>\ntable = [0, 0;\n         1, 0;\n         1, 1;\n         2, 4;\n         3, 9;\n         4, 16];\nextrapolation = 2 (default), timeEvents = 2\nIf, e.g., time = 1.0, the output y =  0.0 (before event), 1.0 (after event)\n    e.g., time = 1.5, the output y =  2.5,\n    e.g., time = 2.0, the output y =  4.0,\n    e.g., time = 5.0, the output y = 23.0 (i.e., extrapolation via last 2 points).\n</pre></blockquote>\n<p>\nThe table matrix can be defined in the following ways:\n</p>\n<ol>\n<li>Explicitly supplied as <strong>parameter matrix</strong> \\table\\,\n    and the other parameters have the following values:\n<blockquote><pre>\ntableName is \\NoName\\ or has only blanks,\nfileName  is \\NoName\\ or has only blanks.\n</pre></blockquote></li>\n<li><strong>Read</strong> from a <strong>file</strong> \\fileName\\ where the matrix is stored as\n    \\tableName\\. Both text and MATLAB MAT-file format is possible.\n    (The text format is described below).\n    The MAT-file format comes in four different versions: v4, v6, v7 and v7.3.\n    The library supports at least v4, v6 and v7 whereas v7.3 is optional.\n    It is most convenient to generate the MAT-file from FreeMat or MATLAB&reg;\n    by command\n<blockquote><pre>\nsave tables.mat tab1 tab2 tab3\n</pre></blockquote>\n    or Scilab by command\n<blockquote><pre>\nsavematfile tables.mat tab1 tab2 tab3\n</pre></blockquote>\n    when the three tables tab1, tab2, tab3 should be used from the model.<br>\n    Note, a fileName can be defined as URI by using the helper function\n    <a href=\\modelica://Modelica.Utilities.Files.loadResource\\>loadResource</a>.</li>\n<li>Statically stored in function \\usertab\\ in file \\usertab.c\\.\n    The matrix is identified by \\tableName\\. Parameter\n    fileName = \\NoName\\ or has only blanks. Row-wise storage is always to be\n    preferred as otherwise the table is reallocated and transposed.</li>\n</ol>\n<p>\nWhen the constant \\NO_FILE_SYSTEM\\ is defined, all file I/O related parts of the\nsource code are removed by the C-preprocessor, such that no access to files takes place.\n</p>\n<p>\nIf tables are read from a text file, the file needs to have the\nfollowing structure (\\-----\\ is not part of the file content):\n</p>\n<blockquote><pre>\n-----------------------------------------------------\n#1\ndouble tab1(6,2)   # comment line\n  0   0\n  1   0\n  1   1\n  2   4\n  3   9\n  4  16\ndouble tab2(6,2)   # another comment line\n  0   0\n  2   0\n  2   2\n  4   8\n  6  18\n  8  32\n-----------------------------------------------------\n</pre></blockquote>\n<p>\nNote, that the first two characters in the file need to be\n\\#1\\ (a line comment defining the version number of the file format).\nAfterwards, the corresponding matrix has to be declared\nwith type (= \\double\\ or \\float\\), name and actual dimensions.\nFinally, in successive rows of the file, the elements of the matrix\nhave to be given. The elements have to be provided as a sequence of\nnumbers in row-wise order (therefore a matrix row can span several\nlines in the file and need not start at the beginning of a line).\nNumbers have to be given according to C syntax (such as 2.3, -2, +2.e4).\nNumber separators are spaces, tab (\\\\t), comma (,), or semicolon (;).\nSeveral matrices may be defined one after another. Line comments start\nwith the hash symbol (#) and can appear everywhere.\nText files should either be ASCII or UTF-8 encoded, where UTF-8 encoded strings are only allowed in line comments and an optional UTF-8 BOM at the start of the text file is ignored.\nOther characters, like trailing non comments, are not allowed in the file.\n</p>\n<p>\nMATLAB is a registered trademark of The MathWorks, Inc.\n</p>\n</html>,revisions=<html>\n<p><strong>Release Notes:</strong></p>\n<ul>\n<li><em>April 09, 2013</em>\n       by Thomas Beutlich:<br>\n       Implemented as external object.</li>\n<li><em>March 31, 2001</em>\n       by <a href=\\http://www.robotic.dlr.de/Martin.Otter/\\>Martin Otter</a>:<br>\n       Used CombiTableTime as a basis and added the\n       arguments <strong>extrapolation, columns, startTime</strong>.\n       This allows periodic function definitions.</li>\n</ul>\n</html>",
    "info=<html>\n<p>\nThis package contains <strong>source</strong> components, i.e., blocks which\nhave only output signals. These blocks are used as signal generators\nfor Real, Integer and Boolean signals.\n</p>\n\n<p>\nAll Real source signals (with the exception of the Constant source)\nhave at least the following two parameters:\n</p>\n\n<table border=\\1\\ cellspacing=\\0\\ cellpadding=\\2\\>\n  <tr><td><strong>offset</strong></td>\n      <td>Value which is added to the signal</td>\n  </tr>\n  <tr><td><strong>startTime</strong></td>\n      <td>Start time of signal. For time &lt; startTime,\n                the output y is set to offset.</td>\n  </tr>\n</table>\n\n<p>\nThe <strong>offset</strong> parameter is especially useful in order to shift\nthe corresponding source, such that at initial time the system\nis stationary. To determine the corresponding value of offset,\nusually requires a trimming calculation.\n</p>\n</html>,revisions=<html>\n<ul>\n<li><em>October 21, 2002</em>\n       by <a href=\\http://www.robotic.dlr.de/Martin.Otter/\\>Martin Otter</a>\n       and Christian Schweiger:<br>\n       Integer sources added. Step, TimeTable and BooleanStep slightly changed.</li>\n<li><em>Nov. 8, 1999</em>\n       by <a href=\\mailto:christoph@clauss-it.com\\>Christoph Clau&szlig;</a>,\n       <a href=\\mailto:Andre.Schneider@eas.iis.fraunhofer.de\\>Andre.Schneider@eas.iis.fraunhofer.de</a>,\n       <a href=\\http://www.robotic.dlr.de/Martin.Otter/\\>Martin Otter</a>:<br>\n       New sources: Exponentials, TimeTable. Trapezoid slightly enhanced\n       (nperiod=-1 is an infinite number of periods).</li>\n<li><em>Oct. 31, 1999</em>\n       by <a href=\\http://www.robotic.dlr.de/Martin.Otter/\\>Martin Otter</a>:<br>\n       <a href=\\mailto:christoph@clauss-it.com\\>Christoph Clau&szlig;</a>,\n       <a href=\\mailto:Andre.Schneider@eas.iis.fraunhofer.de\\>Andre.Schneider@eas.iis.fraunhofer.de</a>,\n       All sources vectorized. New sources: ExpSine, Trapezoid,\n       BooleanConstant, BooleanStep, BooleanPulse, SampleTrigger.\n       Improved documentation, especially detailed description of\n       signals in diagram layer.</li>\n<li><em>June 29, 1999</em>\n       by <a href=\\http://www.robotic.dlr.de/Martin.Otter/\\>Martin Otter</a>:<br>\n       Realized a first version, based on an existing Dymola library\n       of Dieter Moormann and Hilding Elmqvist.</li>\n</ul>\n</html>",
    "info=<html>\n<p>\nThis signal source provides a cosine signal with variable frequency <code>f</code> and variable <code>amplitude</code>,\ni.e. the phase angle of the cosine wave is integrated from 2*&pi;*f.\n</p>\n<p>\nNote that the initial value of the phase angle <code>phi</code> defines the initial phase shift,\nand that the parameter <code>startTime</code> is omitted since the voltage can be kept equal to offset with setting the input <code>amplitude</code> to zero.\n</p>\n</html>",
    "info=<html>\n<p>\nThis signal source provides a sinusoidal signal with variable frequency <code>f</code> and variable <code>amplitude</code>,\ni.e. the phase angle of the sine wave is integrated from 2*&pi;*f.\n</p>\n<p>\nNote that the initial value of the phase angle <code>phi</code> defines the initial phase shift,\nand that the parameter <code>startTime</code> is omitted since the voltage can be kept equal to offset with setting the input <code>amplitude</code> to zero.\n</p>\n</html>",
    "info=<html>\n<p>The output <code>y</code> performs a logarithmic frequency sweep.\nThe logarithm of frequency <code>w</code> performs a linear ramp from <code>log10(wMin)</code> to <code>log10(wMax)</code>.\nThe output is the decimal power of this logarithmic ramp.\n</p>\n<p>For <code>time &lt; startTime</code> the output is equal to <code>wMin</code>.</p>\n<p>For <code>time &gt; startTime+duration</code> the output is equal to <code>wMax</code>.</p>\n<p>\n<img src=\\modelica://Modelica/Resources/Images/Blocks/Sources/LogFrequencySweep.png\\\n     alt=\\LogFrequencySweep.png\\>\n</p>\n\n</html>"
  ],
  "S231P:extends": "Modelica.Icons.SourcesPackage",
  "S231P:icon": [
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=false),graphics={Rectangle(extent={{-100,40},{100,-40}},borderPattern=BorderPattern.Raised,fillColor={235,235,235},fillPattern=FillPattern.Solid),Text(textString=\"%y\",extent={{-96,15},{96,-15}}),Text(textString=\"%name\",textColor={0,0,255},extent={{-150,90},{150,50}}),Polygon(points={{100,10},{120,0},{100,-10},{100,10}},lineColor={255,0,255},fillColor={255,255,255},fillPattern=FillPattern.Solid)}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=false),graphics={Rectangle(extent={{-100,40},{100,-40}},borderPattern=BorderPattern.Raised,fillColor={235,235,235},fillPattern=FillPattern.Solid),Text(textString=\"%y\",extent={{-96,15},{96,-15}}),Text(textString=\"%name\",textColor={0,0,255},extent={{-150,90},{150,50}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=false,initialScale=0.06),graphics={Rectangle(extent={{-100,-100},{100,100}},borderPattern=BorderPattern.Raised,lineColor={128,128,128},fillColor={192,192,192},fillPattern=FillPattern.Solid),Text(textString=\"%name\",textColor={0,0,255},extent={{-300,110},{300,175}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Ellipse(extent={{-80,80},{80,-80}},lineColor={160,160,164}),Line(color={160,160,164},points={{0,80},{0,60}}),Line(color={160,160,164},points={{80,0},{60,0}}),Line(color={160,160,164},points={{0,-80},{0,-60}}),Line(color={160,160,164},points={{-80,0},{-60,0}}),Line(color={160,160,164},points={{37,70},{26,50}}),Line(color={160,160,164},points={{70,38},{49,26}}),Line(color={160,160,164},points={{71,-37},{52,-27}}),Line(color={160,160,164},points={{39,-70},{29,-51}}),Line(color={160,160,164},points={{-39,-70},{-29,-52}}),Line(color={160,160,164},points={{-71,-37},{-50,-26}}),Line(color={160,160,164},points={{-71,37},{-54,28}}),Line(color={160,160,164},points={{-38,70},{-28,51}}),Line(thickness=0.5,points={{0,0},{-50,50}}),Line(thickness=0.5,points={{0,0},{40,0}}),Text(textString=\"startTime=%startTime\",extent={{-150,-150},{150,-110}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(color={192,192,192},points={{-80,64},{-80,-84}}),Polygon(points={{-80,86},{-88,64},{-72,64},{-80,86}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(color={192,192,192},points={{-90,-74},{82,-74}}),Polygon(points={{90,-74},{68,-66},{68,-82},{90,-74}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Rectangle(extent={{-46,68},{4,-52}},lineColor={255,255,255},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(points={{-46,-52},{-46,68},{54,68},{54,-52},{-46,-52},{-46,-22},{54,-22},{54,8},{-46,8},{-46,38},{54,38},{54,68},{4,68},{4,-53}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(color={192,192,192},points={{-80,68},{-80,-80}}),Polygon(points={{-80,90},{-88,68},{-72,68},{-80,90}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(color={192,192,192},points={{-90,-70},{82,-70}}),Polygon(points={{90,-70},{68,-62},{68,-78},{90,-70}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(points={{-80,-70},{-40,-70},{-40,44},{0,44},{0,-70},{40,-70},{40,44},{79,44}}),Text(textString=\"period=%period\",extent={{-147,-152},{153,-112}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(color={192,192,192},points={{-80,68},{-80,-80}}),Polygon(points={{-80,90},{-88,68},{-72,68},{-80,90}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(color={192,192,192},points={{-90,-70},{82,-70}}),Polygon(points={{90,-70},{68,-62},{68,-78},{90,-70}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(points={{-80,-70},{-40,-70},{31,38}}),Text(textString=\"duration=%duration\",extent={{-150,-150},{150,-110}}),Line(points={{31,38},{86,38}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(color={192,192,192},points={{-80,68},{-80,-80}}),Polygon(points={{-80,90},{-88,68},{-72,68},{-80,90}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(color={192,192,192},points={{-90,-70},{82,-70}}),Polygon(points={{90,-70},{68,-62},{68,-78},{90,-70}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(points={{-80,-70},{-60,-70},{0,40},{0,-70},{60,41},{60,-70}}),Text(textString=\"period=%period\",extent={{-147,-152},{153,-112}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(color={192,192,192},points={{-80,68},{-80,-80}}),Polygon(points={{-80,90},{-88,68},{-72,68},{-80,90}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(color={192,192,192},points={{-90,-70},{82,-70}}),Polygon(points={{90,-70},{68,-62},{68,-78},{90,-70}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(points={{-80,-70},{0,-70},{0,50},{80,50}}),Text(textString=\"startTime=%startTime\",extent={{-150,-150},{150,-110}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(color={192,192,192},points={{-80,68},{-80,-80}}),Polygon(points={{-80,90},{-88,68},{-72,68},{-80,90}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(color={192,192,192},points={{-90,-70},{82,-70}}),Polygon(points={{90,-70},{68,-62},{68,-78},{90,-70}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(points={{-80,0},{80,0}}),Text(textString=\"k=%k\",extent={{-150,-150},{150,-110}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(color={192,192,192},points={{-80,68},{-80,-80}}),Polygon(points={{-80,90},{-88,68},{-72,68},{-80,90}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(color={192,192,192},points={{-90,-70},{82,-70}}),Polygon(points={{90,-70},{68,-62},{68,-78},{90,-70}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Rectangle(extent={{-48,70},{2,-50}},lineColor={255,255,255},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(points={{-48,-50},{-48,70},{52,70},{52,-50},{-48,-50},{-48,-20},{52,-20},{52,10},{-48,10},{-48,40},{52,40},{52,70},{2,70},{2,-51}}),Text(textString=\"offset=%offset\",extent={{-150,-150},{150,-110}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(color={192,192,192},points={{-80,68},{-80,-80}}),Polygon(points={{-80,90},{-88,68},{-72,68},{-80,90}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(color={192,192,192},points={{-90,-70},{82,-70}}),Polygon(points={{90,-70},{68,-62},{68,-78},{90,-70}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Text(textString=\"period=%period\",extent={{-147,-152},{153,-112}}),Line(points={{-81,-70},{-60,-70},{-30,40},{9,40},{39,-70},{61,-70},{90,40}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(color={192,192,192},points={{-80,68},{-80,-80}}),Polygon(points={{-80,90},{-88,68},{-72,68},{-80,90}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(color={192,192,192},points={{-90,0},{68,0}}),Polygon(points={{90,0},{68,8},{68,-8},{90,0}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(points={{-80,0},{-68.7,34.2},{-61.5,53.1},{-55.1,66.4},{-49.4,74.6},{-43.8,79.1},{-38.2,79.8},{-32.6,76.6},{-26.9,69.7},{-21.3,59.4},{-14.9,44.1},{-6.83,21.2},{10.1,-30.8},{17.3,-50.2},{23.7,-64.2},{29.3,-73.1},{35,-78.4},{40.6,-80},{46.2,-77.6},{51.9,-71.5},{57.5,-61.9},{63.9,-47.2},{72,-24.8},{80,0}},smooth=Smooth.Bezier),Text(textString=\"f=%f\",extent={{-147,-152},{153,-112}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(color={192,192,192},points={{-80,68},{-80,-80}}),Polygon(points={{-80,90},{-88,68},{-72,68},{-80,90}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(color={192,192,192},points={{-90,0},{68,0}}),Polygon(points={{90,0},{68,8},{68,-8},{90,0}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(points={{-80,0},{-75.2,32.3},{-72,50.3},{-68.7,64.5},{-65.5,74.2},{-62.3,79.3},{-59.1,79.6},{-55.9,75.3},{-52.7,67.1},{-48.6,52.2},{-43,25.8},{-35,-13.9},{-30.2,-33.7},{-26.1,-45.9},{-22.1,-53.2},{-18.1,-55.3},{-14.1,-52.5},{-10.1,-45.3},{-5.23,-32.1},{8.44,13.7},{13.3,26.4},{18.1,34.8},{22.1,38},{26.9,37.2},{31.8,31.8},{38.2,19.4},{51.1,-10.5},{57.5,-21.2},{63.1,-25.9},{68.7,-25.9},{75.2,-20.5},{80,-13.8}},smooth=Smooth.Bezier),Text(textString=\"f=%f\",extent={{-147,-152},{153,-112}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(color={192,192,192},points={{-80,68},{-80,-80}}),Polygon(points={{-80,90},{-88,68},{-72,68},{-80,90}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(color={192,192,192},points={{-90,0},{68,0}}),Polygon(points={{90,0},{68,8},{68,-8},{90,0}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(points={{-80,0},{-78.4,0},{-76.8,0},{-75.2,0},{-73.6,0.1},{-72,0.1},{-70.4,0.2},{-68.8,0.3},{-67.2,0.4},{-65.6,0.6},{-64,0.8},{-62.4,1.1},{-60.8,1.4},{-59.2,1.8},{-57.6,2.2},{-56,2.7},{-54.4,3.3},{-52.8,3.9},{-51.2,4.6},{-49.6,5.4},{-48,6.2},{-46.4,7.2},{-44.8,8.2},{-43.2,9.2},{-41.6,10.4},{-40,11.6},{-38.4,12.9},{-36.8,14.2},{-35.2,15.6},{-33.6,17.1},{-32,18.6},{-30.4,20.1},{-28.8,21.6},{-27.2,23.1},{-25.6,24.6},{-24,26.1},{-22.4,27.5},{-20.8,28.8},{-19.2,30},{-17.6,31.1},{-16,32},{-14.4,32.7},{-12.8,33.2},{-11.2,33.5},{-9.6,33.5},{-8,33.2},{-6.4,32.5},{-4.8,31.5},{-3.2,30.1},{-1.6,28.4},{0,26.2},{1.6,23.6},{3.2,20.6},{4.8,17.2},{6.4,13.3},{8,9.1},{9.6,4.6},{11.2,-0.3},{12.8,-5.4},{14.4,-10.7},{16,-16.1},{17.6,-21.6},{19.2,-27.1},{20.8,-32.3},{22.4,-37.4},{24,-42.1},{25.6,-46.3},{27.2,-49.9},{28.8,-52.8},{30.4,-54.8},{32,-56},{33.6,-56.1},{35.2,-55.2},{36.8,-53.1},{38.4,-49.8},{40,-45.3},{41.6,-39.7},{43.2,-33},{44.8,-25.3},{46.4,-16.6},{48,-7.3},{49.6,2.6},{51.2,12.8},{52.8,23},{54.4,33},{56,42.5},{57.6,51.2},{59.2,58.8},{60.8,64.9},{62.4,69.3},{64,71.9},{65.6,72.3},{67.2,70.5},{68.8,66.4},{70.4,60},{72,51.4},{73.6,40.8},{75.2,28.4},{76.8,14.7},{78.4,0},{80,-15.1}},smooth=Smooth.Bezier)}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(color={192,192,192},points={{-80,68},{-80,-80}}),Polygon(points={{-80,90},{-88,68},{-72,68},{-80,90}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(color={192,192,192},points={{-90,0},{68,0}}),Polygon(points={{90,0},{68,8},{68,-8},{90,0}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(points={{-80,80},{-76.2,79.8},{-70.6,76.6},{-64.9,69.7},{-59.3,59.4},{-52.9,44.1},{-44.83,21.2},{-27.9,-30.8},{-20.7,-50.2},{-14.3,-64.2},{-8.7,-73.1},{-3,-78.4},{2.6,-80},{8.2,-77.6},{13.9,-71.5},{19.5,-61.9},{25.9,-47.2},{34,-24.8},{42,0}},smooth=Smooth.Bezier),Text(textString=\"f=%f\",extent={{-147,-152},{153,-112}}),Line(points={{42,1},{53.3,35.2},{60.5,54.1},{66.9,67.4},{72.6,75.6},{78.2,80.1},{83.8,80.8}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(color={192,192,192},points={{-80,68},{-80,-80}}),Polygon(points={{-80,90},{-88,68},{-72,68},{-80,90}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(color={192,192,192},points={{-90,0},{68,0}}),Polygon(points={{90,0},{68,8},{68,-8},{90,0}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(points={{-80,80},{-78.4,79.6},{-76.8,79.2},{-75.2,78.8},{-73.6,78.4},{-72,78},{-70.4,77.5},{-68.8,77.1},{-67.2,76.6},{-65.6,76.1},{-64,75.6},{-62.4,75},{-60.8,74.4},{-59.2,73.7},{-57.6,73},{-56,72.2},{-54.4,71.3},{-52.8,70.3},{-51.2,69.2},{-49.6,68},{-48,66.6},{-46.4,65.2},{-44.8,63.6},{-43.2,61.8},{-41.6,59.9},{-40,57.7},{-38.4,55.5},{-36.8,53},{-35.2,50.3},{-33.6,47.5},{-32,44.4},{-30.4,41.1},{-28.8,37.7},{-27.2,34},{-25.6,30.1},{-24,26.1},{-22.4,21.9},{-20.8,17.5},{-19.2,13},{-17.6,8.3},{-16,3.5},{-14.4,-1.3},{-12.8,-6.2},{-11.2,-11.1},{-9.6,-16},{-8,-20.8},{-6.4,-25.5},{-4.8,-30.1},{-3.2,-34.5},{-1.6,-38.6},{0,-42.4},{1.6,-45.9},{3.2,-49},{4.8,-51.7},{6.4,-53.9},{8,-55.5},{9.6,-56.5},{11.2,-57},{12.8,-56.8},{14.4,-55.9},{16,-54.4},{17.6,-52.2},{19.2,-49.3},{20.8,-45.7},{22.4,-41.5},{24,-36.7},{25.6,-31.4},{27.2,-25.6},{28.8,-19.4},{30.4,-12.9},{32,-6.2},{33.6,0.6},{35.2,7.4},{36.8,14},{38.4,20.4},{40,26.3},{41.6,31.8},{43.2,36.5},{44.8,40.6},{46.4,43.7},{48,45.9},{49.6,47.1},{51.2,47.2},{52.8,46.2},{54.4,44.1},{56,41},{57.6,36.8},{59.2,31.8},{60.8,25.9},{62.4,19.4},{64,12.4},{65.6,5.1},{67.2,-2.2},{68.8,-9.5},{70.4,-16.4},{72,-22.8},{73.6,-28.4},{75.2,-33},{76.8,-36.6},{78.4,-38.9},{80,-39.8}},smooth=Smooth.Bezier)}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(color={192,192,192},points={{-80,68},{-80,-80}}),Polygon(points={{-80,90},{-88,68},{-72,68},{-80,90}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(color={192,192,192},points={{-90,0},{68,0}}),Polygon(points={{90,0},{68,8},{68,-8},{90,0}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Text(textString=\"f=%f\",textColor={0,0,0},extent={{-147,-152},{153,-112}}),Line(points={{-80,80},{-76,78.7},{-72,74.8},{-68,68.7},{-64,60.5},{-60,50.9},{-56,40.4},{-52,29.4},{-48,18.7},{-44,8.7},{-40,0},{-36,-7.2},{-32,-12.5},{-28,-15.8},{-24,-17.3},{-20,-17},{-16,-15.1},{-12,-12.1},{-8,-8.3},{-4,-4.1},{0,0},{4,3.7},{8,6.8},{12,9},{16,10.1},{20,10.2},{24,9.3},{28,7.6},{32,5.3},{36,2.7},{40,0},{44,-2.5},{48,-4.7},{52,-6.2},{56,-7.1},{60,-7.3},{64,-6.7},{68,-5.6},{72,-3.9},{76,-2},{80,0}},smooth=Smooth.Bezier)}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(color={192,192,192},points={{-80,78},{-80,-82}}),Polygon(points={{-80,90},{-88,68},{-72,68},{-80,88},{-80,90}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(color={192,192,192},points={{-90,0},{17,0}}),Line(points={{-80,0},{-70,0},{-70,70},{-50,70},{-50,0},{-15,0},{-15,-70},{5,-70},{5,0},{18,0}}),Text(textString=\"q\",extent={{34,96},{94,66}}),Text(textString=\"qd\",extent={{40,44},{96,14}}),Text(textString=\"qdd\",extent={{32,-18},{99,-44}}),Text(textString=\"moving\",extent={{-32,-74},{97,-96}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(color={192,192,192},points={{-80,78},{-80,-82}}),Polygon(points={{-80,90},{-88,68},{-72,68},{-80,88},{-80,90}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(color={192,192,192},points={{-90,0},{82,0}}),Polygon(points={{90,0},{68,8},{68,-8},{90,0}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(points={{-80,0},{-70,0},{-70,70},{-30,70},{-30,0},{20,0},{20,-70},{60,-70},{60,0},{68,0}}),Text(textString=\"acc\",textColor={192,192,192},extent={{2,80},{80,20}}),Text(textString=\"deltaq=%deltaq\",extent={{-150,-150},{150,-110}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(color={192,192,192},points={{-90,-70},{68,-70}}),Polygon(points={{90,-70},{68,-62},{68,-78},{90,-70}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(points={{-80,-70},{-77.2,-55.3},{-74.3,-42.1},{-70.8,-27.6},{-67.3,-15},{-63.7,-4.08},{-59.5,7.18},{-55.3,16.7},{-50.3,26},{-44.6,34.5},{-38.3,42.1},{-31.2,48.6},{-22.7,54.3},{-12.1,59.2},{-10,60},{-7.88,47.5},{-5.05,32.7},{-2.22,19.8},{0.606,8.45},{4.14,-3.7},{7.68,-14},{11.9,-24.2},{16.2,-32.6},{21.1,-40.5},{26.8,-47.4},{33.1,-53.3},{40.9,-58.5},{50.8,-62.8},{60,-65.4}}),Polygon(points={{-80,90},{-88,68},{-72,68},{-80,90}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(color={192,192,192},points={{-80,68},{-80,-80}}),Text(textString=\"riseTime=%riseTime\",extent={{-150,-150},{150,-110}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(points={{-60,-70},{-60,70}}),Line(points={{-20,-70},{-20,70}}),Line(points={{20,-70},{20,70}}),Line(points={{60,-70},{60,70}}),Text(textString=\"%period\",extent={{-150,-140},{150,-110}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(points={{-80,-70},{0,-70},{0,50},{80,50}},visible=not startValue),Line(points={{-80,50},{0,50},{0,-70},{68,-70}},visible=startValue),Text(textString=\"%startTime\",extent={{-150,-140},{150,-110}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Line(points={{-80,0},{80,0}}),Text(textString=\"%k\",extent={{-150,-140},{150,-110}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Polygon(points={{-80,88},{-88,66},{-72,66},{-80,88}},lineColor={255,0,255},fillColor={255,0,255},fillPattern=FillPattern.Solid),Line(color={255,0,255},points={{-80,66},{-80,-82}}),Line(color={255,0,255},points={{-90,-70},{72,-70}}),Polygon(points={{90,-70},{68,-62},{68,-78},{90,-70}},lineColor={255,0,255},fillColor={255,0,255},fillPattern=FillPattern.Solid),Rectangle(extent={{-18,70},{32,-50}},lineColor={255,255,255},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(points={{-18,-50},{-18,70},{32,70},{32,-50},{-18,-50},{-18,-20},{32,-20},{32,10},{-18,10},{-18,40},{32,40},{32,70},{32,70},{32,-51}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Polygon(points={{-80,90},{-88,68},{-72,68},{-80,90}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(color={192,192,192},points={{-80,68},{-80,-80}}),Line(color={192,192,192},points={{-90,-70},{82,-70}}),Polygon(points={{90,-70},{68,-62},{68,-78},{90,-70}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Rectangle(extent={{-48,-50},{2,70}},lineColor={255,255,255},fillColor={255,215,136},fillPattern=FillPattern.Solid),Line(points={{-48,-50},{-48,70},{52,70},{52,-50},{-48,-50},{-48,-20},{52,-20},{52,10},{-48,10},{-48,40},{52,40},{52,70},{2,70},{2,-51}})}",
    "coordinateSystem(extent={{-100,-100},{100,100}},preserveAspectRatio=true),graphics={Text(textString=\"%period\",extent={{-150,-140},{150,-110}}),Line(points={{-80,-70},{-40,-70},{-40,44},{0,44},{0,-70},{40,-70},{40,44},{79,44}})}",
    "graphics={Line(color={192,192,192},points={{-78,44},{80,44}}),Line(color={192,192,192},points={{-78,34},{80,34}}),Line(color={192,192,192},points={{-78,20},{80,20}}),Line(color={192,192,192},points={{-78,-2},{80,-2}}),Line(color={192,192,192},points={{-78,-48},{80,-48}}),Line(color={0,0,127},thickness=0.5,points={{-70,-48},{-50,-48},{50,44},{70,44}}),Line(color={192,192,192},points={{-50,-48},{-50,44}}),Line(color={192,192,192},points={{50,-48},{50,44}}),Line(color={192,192,192},points={{-78,40},{80,40}}),Polygon(points={{90,-48},{68,-40},{68,-56},{90,-48}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Polygon(points={{-70,90},{-78,68},{-62,68},{-70,90}},lineColor={192,192,192},fillColor={192,192,192},fillPattern=FillPattern.Solid),Line(color={192,192,192},points={{-70,-56},{-70,68}})}"
  ],
  "S231P:label": [
    "BooleanConstant",
    "BooleanExpression",
    "BooleanPulse",
    "BooleanStep",
    "BooleanTable",
    "CombiTimeTable",
    "Constant",
    "ContinuousClock",
    "Cosine",
    "CosineVariableFrequencyAndAmplitude",
    "ExpSine",
    "Exponentials",
    "IntegerConstant",
    "IntegerExpression",
    "IntegerStep",
    "IntegerTable",
    "KinematicPTP",
    "KinematicPTP2",
    "LogFrequencySweep",
    "Pulse",
    "RadioButtonSource",
    "Ramp",
    "RealExpression",
    "SampleTrigger",
    "SawTooth",
    "Sinc",
    "Sine",
    "SineVariableFrequencyAndAmplitude",
    "Sources",
    "Step",
    "TimeTable",
    "Trapezoid"
  ]
}